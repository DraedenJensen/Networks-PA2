import pox
from pox.core import core
log = core.getLogger()

from pox.lib.packet.ethernet import ethernet, ETHER_BROADCAST
from pox.lib.packet.arp import arp
from pox.lib.packet.vlan import vlan
from pox.lib.addresses import IPAddr, EthAddr
from pox.lib.util import dpid_to_str, str_to_bool
from pox.lib.recoco import Timer
from pox.lib.revent import EventHalt

import pox.openflow.libopenflow_01 

def launch():
  log.info("Controller launched")
  core.addListenerByName("UpEvent", _handle_UpEvent)
  core.openflow.addListenerByName("ConnectionUp", _handle_ConnectionUp)
  core.openflow.addListenerByName("PacketIn", _handle_PacketIn)

def _handle_UpEvent(event):
  log.info("Controller set up")


def _handle_ConnectionUp(event):
  log.info("Switch connected, listening for packets")

  '''
  What I need to do
  - Intercept ARP request
  - Select which of the two servers to use for the request, and send the MAC address back to the sender host.
  - Add forwarding rules to map the virtual IP address with the real IP address of the selected server. The host and the server must be connected in both directions.
  '''
def _handle_PacketIn(event):
  dpid = event.connection.dpid
  in_port = event.port
  packet = event.parsed

  if not packet.parsed:
    log.warning("Packet received but couldn't be parsed")
    return

  log.info(f"Packet received: {packet}")

  if packet.type == packet.ARP_TYPE:
    if packet.payload.opcode == arp.REQUEST:
      log.info(f"ARP request received; src: {packet.payload.protosrc}, dest: {packet.payload.protodst}")
      reply = arp()
      if packet.payload.protosrc == IPAddr("10.0.0.1") | packet.payload.protosrc == IPAddr("10.0.0.3") :
        reply.hwsrc = EthAddr("00:00:00:00:00:05")
        reply.protosrc = IPAddr("10.0.0.5")
      elif packet.payload.protosrc == IPAddr("10.0.0.2") | packet.payload.protosrc == IPAddr("10.0.0.4") :
        reply.hwsrc = EthAddr("00:00:00:00:00:06")
        reply.protosrc = IPAddr("10.0.0.6")
      reply.hwdst = packet.src
      reply.opcode = arp.REPLY
      reply.protodst = packet.payload.protosrc

      ether = ethernet()
      ether.type = ethernet.ARP_TYPE
      ether.dst = packet.src
      ether.src = reply.hwsrc
      ether.payload = reply

      msg = of.ofp_packet_out()
      msg.data = e.pack()
      msg.actions.append(of.ofp_action_output(port = of.OFPP_IN_PORT))
      msg.in_port = inport
      event.connection.send(msg)
    else:
      log.info("Ignoring non-request ARP packet")
  else:
    log.debug("Ignoring non-ARP packet")
    return

    
'''
def _handle_ARP(self, event):
    # Note: arp.hwsrc is not necessarily equal to ethernet.src
    # (one such example are arp replies generated by this module itself
    # as ethernet mac is set to switch dpid) so we should be careful
    # to use only arp addresses in the learning code!
    squelch = False

    dpid = event.connection.dpid
    inport = event.port
    packet = event.parsed
    if not packet.parsed:
      log.warning("%s: ignoring unparsed packet", dpid_to_str(dpid))
      return

    a = packet.find('arp')
    if not a: return

    log.debug("%s ARP %s %s => %s", dpid_to_str(dpid),
      {arp.REQUEST:"request",arp.REPLY:"reply"}.get(a.opcode,
      'op:%i' % (a.opcode,)), str(a.protosrc), str(a.protodst))

    if a.prototype == arp.PROTO_TYPE_IP:
      if a.hwtype == arp.HW_TYPE_ETHERNET:
        if a.protosrc != 0:

          if _learn:
            # Learn or update port/MAC info
            old_entry = _arp_table.get(a.protosrc)
            if old_entry is None:
              log.info("%s learned %s", dpid_to_str(dpid), a.protosrc)
              _arp_table[a.protosrc] = Entry(a.hwsrc)
            else:
              if old_entry.mac is True:
                # We never replace these special cases.
                # Might want to warn on conflict?
                pass
              elif old_entry.mac != a.hwsrc:
                if old_entry.static:
                  log.warn("%s static entry conflict %s: %s->%s",
                      dpid_to_str(dpid), a.protosrc, old_entry.mac, a.hwsrc)
                else:
                  log.warn("%s RE-learned %s: %s->%s", dpid_to_str(dpid),
                      a.protosrc, old_entry.mac, a.hwsrc)
                  _arp_table[a.protosrc] = Entry(a.hwsrc)
              else:
                # Update timestamp
                _arp_table[a.protosrc] = Entry(a.hwsrc)

          if a.opcode == arp.REQUEST:
            # Maybe we can answer

            if a.protodst in _arp_table:
              # We have an answer...

              r = arp()
              r.hwtype = a.hwtype
              r.prototype = a.prototype
              r.hwlen = a.hwlen
              r.protolen = a.protolen
              r.opcode = arp.REPLY
              r.hwdst = a.hwsrc
              r.protodst = a.protosrc
              r.protosrc = a.protodst
              mac = _arp_table[a.protodst].mac
              if mac is True:
                # Special case -- use ourself
                mac = event.connection.eth_addr
              r.hwsrc = mac
              e = ethernet(type=packet.type, src=event.connection.eth_addr,
                           dst=a.hwsrc)
              e.payload = r
              if packet.type == ethernet.VLAN_TYPE:
                v_rcv = packet.find('vlan')
                e.payload = vlan(eth_type = e.type,
                                 payload = e.payload,
                                 id = v_rcv.id,
                                 pcp = v_rcv.pcp)
                e.type = ethernet.VLAN_TYPE
              log.info("%s answering ARP for %s" % (dpid_to_str(dpid),
                str(r.protosrc)))
              msg = of.ofp_packet_out()
              msg.data = e.pack()
              msg.actions.append(of.ofp_action_output(port =
                                                      of.OFPP_IN_PORT))
              msg.in_port = inport
              event.connection.send(msg)
              return EventHalt if _eat_packets else None
            else:
              # Keep track of failed queries
              squelch = a.protodst in _failed_queries
              _failed_queries[a.protodst] = time.time()

    if self._check_for_flood(dpid, a):
      # Didn't know how to handle this ARP, so just flood it
      msg = "%s flooding ARP %s %s => %s" % (dpid_to_str(dpid),
          {arp.REQUEST:"request",arp.REPLY:"reply"}.get(a.opcode,
          'op:%i' % (a.opcode,)), a.protosrc, a.protodst)

      if squelch:
        log.debug(msg)
      else:
        log.info(msg)

      msg = of.ofp_packet_out()
      msg.actions.append(of.ofp_action_output(port = of.OFPP_FLOOD))
      msg.data = event.ofp
      event.connection.send(msg.pack())

    return EventHalt if _eat_packets else None
'''